### Ответы на теоретические вопросы

#### 1. Распространение событий в JavaScript (Event Propagation)

Event Propagation — это механизм, который определяет, как события распространяются через DOM-дерево к элементу-цели (event target) и/или от него.

**Основные фазы:**

1.  **Фаза захвата (Capturing Phase):** Событие "спускается" от самого верхнего элемента (`window`) вниз по иерархии DOM к элементу, на котором оно произошло. На этой фазе можно перехватить событие до того, как оно достигнет своей цели.

2.  **Фаза цели (Target Phase):** Событие достигает целевого элемента — того, на котором оно было инициировано (например, по которому кликнули).

3.  **Фаза всплытия (Bubbling Phase):** После фазы цели событие "всплывает" обратно вверх по иерархии DOM от целевого элемента до `window`. Это самая часто используемая фаза для обработки событий.

**Применение на практике:**

- **Делегирование событий:** Это самый распространенный способ применения. Вместо того чтобы вешать обработчик на каждый дочерний элемент в большом списке, можно повесить один обработчик на их общего родителя. Благодаря всплытию, клик по любому дочернему элементу вызовет обработчик на родителе. Это экономит память и упрощает код, особенно для динамически добавляемых элементов.

  - _Пример:_ В нашем каталоге фильмов, вместо того чтобы вешать `(click)` на каждую карточку, можно было бы повесить один `(click)` на контейнер `catalog__grid` и определять, по какой карточке кликнули, через `event.target`.

- **Перехват событий:** Фаза захвата используется реже, но может быть полезна, когда нужно гарантированно обработать событие до того, как его обработает или остановит (`event.stopPropagation()`) дочерний элемент. Для этого при добавлении обработчика `addEventListener` нужно передать третий аргумент `{ capture: true }`.

- **Остановка распространения:** С помощью метода `event.stopPropagation()` можно остановить дальнейшее распространение события (всплытие или захват). `event.stopImmediatePropagation()` делает то же самое, плюс останавливает выполнение других обработчиков на том же элементе.

---

#### 2. Promise, асинхронный код и Event Loop

**Что такое Promise?**

Promise (обещание) — это специальный объект в JavaScript, который представляет собой будущее значение, результат асинхронной операции. Promise может находиться в одном из трех состояний:

1.  **`pending` (ожидание):** Начальное состояние, операция еще не завершена.
2.  **`fulfilled` (выполнено успешно):** Операция завершилась успешно, и Promise содержит результат (значение).
3.  **`rejected` (отклонено):** Операция завершилась с ошибкой, и Promise содержит информацию об ошибке.

Promise является "одноразовым" — из состояния `pending` он может перейти либо в `fulfilled`, либо в `rejected`, но не обратно.

**Как он работает?**

Promise имеет методы `.then()`, `.catch()` и `.finally()` для обработки результатов.

- `.then(onFulfilled, onRejected)`: Принимает две функции-колбэка. Первая вызывается при успешном выполнении, вторая (опционально) — при ошибке.
- `.catch(onRejected)`: Синтаксический сахар для `.then(null, onRejected)`, используется для обработки ошибок.
- `.finally(onFinally)`: Вызывается в любом случае, когда Promise завершен (успешно или с ошибкой).

**Другие способы обработки асинхронного кода:**

- **Колбэки (Callbacks):** "Классический" способ. Функция, которая должна выполниться после завершения асинхронной операции, передается в качестве аргумента. Главный минус — "ад колбэков" (Callback Hell), когда вложенность становится слишком большой, и код трудно читать.
- **Async/Await:** Синтаксическая надстройка над Promise, появившаяся в ES2017. Она позволяет писать асинхронный код, который выглядит и читается как синхронный.
  - `async` перед функцией означает, что она всегда возвращает Promise.
  - `await` можно использовать только внутри `async`-функции. Он заставляет JavaScript ждать, пока Promise не будет выполнен, и возвращает его результат. Для обработки ошибок используется стандартная конструкция `try...catch`.

**Роль Event Loop (событийного цикла):**

Event Loop — это механизм, который позволяет JavaScript, будучи однопоточным языком, выполнять асинхронные операции без блокировки основного потока выполнения.

- **Call Stack (Стек вызовов):** Место, где выполняются функции.
- **Web APIs (или C++ APIs в Node.js):** Среда выполнения (браузер, Node.js) предоставляет API для асинхронных операций (`setTimeout`, `fetch`, `DOM events`). Когда мы вызываем такую операцию, она передается в Web API.
- **Callback Queue (Очередь колбэков):** Когда асинхронная операция в Web API завершается, ее колбэк помещается в эту очередь.
- **Event Loop:** Его задача проста — постоянно проверять, пуст ли Call Stack. Если стек пуст, Event Loop берет первый колбэк из очереди и помещает его в стек для выполнения.

Этот механизм гарантирует, что долго выполняющиеся операции (например, сетевые запросы) не "заморозят" интерфейс пользователя.

---

#### 3. Объектно-ориентированное программирование (ООП) в JavaScript

**Что такое ООП?**

ООП — это парадигма программирования, основанная на концепции "объектов", которые могут содержать данные (в виде полей или свойств) и код (в виде процедур или методов).

**Ключевые принципы ООП:**

1.  **Инкапсуляция:** Объединение данных и методов, которые работают с этими данными, внутри одного объекта. При этом детали реализации скрыты от внешнего мира, и наружу предоставляется только публичный интерфейс.

    - _Пример:_ В нашем приложении `MovieService` инкапсулирует логику получения данных. Компонентам не нужно знать, как именно он это делает (через `HttpClient`, `fetch` или что-то еще), они просто вызывают метод `getMovies()`.

2.  **Наследование:** Механизм, который позволяет одному классу (потомку) унаследовать свойства и методы другого класса (родителя). Это способствует переиспользованию кода (принцип DRY - Don't Repeat Yourself).

    - _Пример:_ Можно создать базовый класс `BaseComponent` с общей логикой (например, отписка от подписок в `ngOnDestroy`), а все остальные компоненты будут наследоваться от него.

3.  **Полиморфизм:** Способность объектов с одинаковым интерфейсом (набором методов) иметь разную реализацию этих методов. Это позволяет писать более гибкий и обобщенный код.

    - _Пример:_ Можно создать интерфейс `Exporter` с методом `export(data)`. Затем создать классы `JsonExporter` и `CsvExporter`, которые реализуют этот интерфейс по-разному. Функция, принимающая `Exporter`, сможет работать с любым из этих классов, не зная о его внутренней реализации.

4.  **Абстракция:** Выделение наиболее значимых характеристик объекта и отбрасывание второстепенных. Мы создаем упрощенную модель реального объекта, с которой проще работать.
    - _Пример:_ Наша модель `Movie` — это абстракция. Реальный фильм имеет гораздо больше характеристик (режиссер, актеры, бюджет и т.д.), но для нашего каталога мы выделили только те, что нам нужны (`id`, `title`, `year`...).

**Реализация ООП в JavaScript:**

JavaScript является прототипно-ориентированным языком, но с появлением стандарта ES6 (2015) в нем появился синтаксический сахар в виде `class`, который делает работу с объектами похожей на классические ООП-языки (Java, C#).

- **Классы и конструкторы:** Класс определяется с помощью ключевого слова `class`. Метод `constructor` вызывается при создании нового экземпляра через оператор `new`.
- **Наследование:** Используется ключевое слово `extends`. В конструкторе дочернего класса необходимо вызвать `super()` для вызова конструктора родителя.
- **Инкапсуляция:** До недавнего времени инкапсуляция достигалась через замыкания или соглашения (например, `_privateProperty`). Сейчас в классах можно использовать синтаксис с `#` для создания приватных полей и методов (`#privateField`).
- **Прототипы:** Под "капотом" классы в JS все равно работают через прототипы. Каждый объект имеет скрытое свойство `[[Prototype]]`, которое ссылается на другой объект (его прототип). Когда мы пытаемся получить доступ к свойству объекта, и его нет в самом объекте, JS ищет его в прототипе, затем в прототипе прототипа и так далее по цепочке, пока не дойдет до `null`.

---

#### 4. Как браузер обрабатывает URL

Процесс от ввода URL в адресную строку до отображения страницы — это сложная последовательность шагов.

1.  **Парсинг URL:** Пользователь вводит URL (например, `https://google.com`) и нажимает Enter. Браузер парсит строку, чтобы определить протокол (`https`), хост (`google.com`), порт (по умолчанию 443 для https) и путь.

2.  **Поиск в кеше:** Браузер проверяет несколько уровней кеша, чтобы узнать, не посещали ли мы этот адрес недавно:

    - **Browser cache:** Есть ли ресурс в собственном кеше браузера?
    - **OS cache:** Есть ли запись в кеше операционной системы?
    - **Router cache:** Кеш на уровне роутера.
    - **ISP cache:** Кеш провайдера.
      Если ресурс найден в кеше и он не устарел, браузер сразу отображает его, пропуская следующие шаги.

3.  **DNS-запрос (Domain Name System):** Если IP-адрес для хоста `google.com` не найден в кеше, браузер делает DNS-запрос, чтобы преобразовать доменное имя в IP-адрес. Это похоже на поиск номера телефона в телефонной книге.

4.  **Установление TCP-соединения:** Получив IP-адрес, браузер устанавливает с сервером TCP-соединение. Для `https` это будет защищенное соединение. Происходит "тройное рукопожатие" (three-way handshake: SYN -> SYN-ACK -> ACK) для установки связи.

5.  **TLS-рукопожатие (Transport Layer Security):** Для HTTPS-соединения поверх TCP происходит TLS-рукопожатие для установки зашифрованного канала. Браузер и сервер обмениваются ключами, проверяют сертификаты, чтобы убедиться, что данные будут передаваться безопасно.

6.  **Отправка HTTP-запроса:** Браузер формирует и отправляет HTTP-запрос на сервер. Запрос содержит:

    - **Request Line:** Метод (`GET`), путь (`/`), версия протокола (`HTTP/1.1`).
    - **Headers:** Заголовки с дополнительной информацией (`Host`, `User-Agent`, `Accept`, `Cookie` и др.).
    - **Body:** Тело запроса (обычно пустое для `GET`-запросов).

7.  **Ожидание ответа от сервера:** Сервер обрабатывает запрос, находит нужный ресурс (HTML-файл) и отправляет обратно HTTP-ответ. Ответ содержит:

    - **Status Line:** Версия протокола, код состояния (`200 OK`) и его описание.
    - **Headers:** Заголовки ответа (`Content-Type`, `Content-Length`, `Set-Cookie` и др.).
    - **Body:** Содержимое ресурса (HTML-код страницы).

8.  **Парсинг и рендеринг:**

    - Браузер получает HTML и начинает его парсить, строя **DOM-дерево (Document Object Model)**.
    - Встречая в HTML теги `<link rel="stylesheet">` или `<style>`, он начинает парсить CSS и строить **CSSOM-дерево (CSS Object Model)**.
    - На основе DOM и CSSOM браузер строит **Render Tree (дерево рендеринга)**, которое содержит только видимые узлы и их стили.
    - **Layout (или Reflow):** На этом этапе вычисляется геометрия каждого узла (размеры и положение на экране).
    - **Painting:** На последнем этапе происходит "отрисовка" пикселей на экране.

9.  **Загрузка дополнительных ресурсов:** В процессе парсинга HTML, если браузер встречает теги `<script>`, `<img>`, он инициирует новые HTTP-запросы для загрузки этих ресурсов, которые проходят те же этапы (кеш, DNS, TCP и т.д.). Загрузка и выполнение скриптов может блокировать рендеринг страницы.

**Технологии для ускорения процесса:**

- **Кеширование:** Использование HTTP-заголовков (`Cache-Control`, `Expires`) для хранения ресурсов на клиенте.
- **CDN (Content Delivery Network):** Размещение контента на серверах, географически близких к пользователю.
- **HTTP/2 и HTTP/3:** Новые версии протокола, поддерживающие мультиплексирование (одновременная загрузка нескольких ресурсов по одному соединению).
- **Минификация и сжатие:** Уменьшение размера HTML, CSS, JS файлов и использование сжатия (Gzip, Brotli).
- **Оптимизация изображений:** Использование современных форматов (WebP, AVIF) и ленивая загрузка (`loading="lazy"`).
- **Асинхронная загрузка JS:** Использование атрибутов `async` и `defer` для тега `<script>`, чтобы не блокировать рендеринг.

**Возможные проблемы:**

- **Безопасность:**
  - **XSS (Cross-Site Scripting):** Внедрение вредоносного кода на страницу, который выполнится в браузере другого пользователя.
  - **CSRF (Cross-Site Request Forgery):** Принуждение пользователя выполнить нежелательные действия на сайте, где он аутентифицирован.
  - **Атаки "человек посередине" (Man-in-the-Middle):** Перехват трафика, если не используется HTTPS.
- **Междоменное взаимодействие:**
  - **CORS (Cross-Origin Resource Sharing):** Политика безопасности браузера, которая по умолчанию запрещает делать AJAX-запросы к домену, отличному от того, с которого загружена страница. Для разрешения таких запросов сервер должен отправлять специальные CORS-заголовки (`Access-Control-Allow-Origin`).
